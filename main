#!/bin/bash
#PBS -l nodes=1:ppn=8,walltime=4:00:00,vmem=30gb
#PBS -N fmriprep

set -x
set -e

#write out *plugin* configuration for fmriprep to limit mem/cpus
#this can't prevent the fmriprep/nipype bootup vmem spiking (could kill the job)
cat <<EOF > multi_proc.yml
plugin: LegacyMultiProc
plugin_args: {maxtasksperchild: 1, memory_gb: 28, n_procs: 8, raise_insufficient: false}
EOF

source bids_funcs.sh

WORKDIRNAME=fmripworkdir
outdir=fmripout
INDIRNAME=fmripinput
DERIVOUTNAME=output

# manually change "subject" in config.json to "TTTEMPSUB" to work with fMRIPrep

cat config.json | jq '._inputs[].meta.subject="TTTEMPSUB"' > tmp1.json
cat tmp1.json | jq '._inputs[].meta.session="SSSES"' > tmp2.json
cat tmp2.json | jq '._inputs[].meta.run="1"' > tmp3.json

mv tmp3.json config.json && rm tmp?.json

################################################################################
# read input from config.json
# starting off with basic options here

inT1w=`jq -r '.t1' config.json`
inT2w=`jq -r '.t2' config.json`
inFMRI=`jq -r '.fmri' config.json`
inFSDIR=`jq -r '.fsin' config.json`

# templates to be resampled to
templates_bool=(`jq -r '.["T1w:res-2"], .["MNI152NLin2009cAsym"], .["fsaverage:den-10k"]' config.json`)
template_names=("T1w:res-2" "MNI152NLin2009cAsym" "fsaverage:den-10k")
outTEMPLATES="T1w MNI152NLin2009cAsym:res-2" # T1w and MNI152NLin2009cAsym:res-2 are required
for i in {0..2}
  do if ${templates_bool[$i]}; then
    outTEMPLATES=$(echo "$outTEMPLATES" "${template_names[$i]}")
  fi
done

#inODIR=`jq -r '.inodir' config.json`
#inWDIR=`jq -r '.inwdir' config.json`

#debug
#hostname
#vmstat
#cat /proc/sys/vm/overcommit_memory
#cat /proc/sys/vm/overcommit_ratio
#cat /proc/sys/vm/swappiness
#cat /proc/meminfo

# some logical checks
if [[ $inT1w = "null" ]] || [[ $inFMRI = "null" ]] ; then
	echo "app needs minimally a T1w and fmri. exiting"
	exit 1
fi

# extract info from brainlife interface, base on T1w
# get the staging dir, this is where meta information is 
stagingDir=$(dirname $inT1w)
echo "ls dir where initial bl info read--> $stagingDir"
ls -dl $stagingDir

if [[ $stagingDir = "." ]]; then
   echo "error finding staging directory. exiting"
   exit 1
fi

jq '._inputs[] | select(.id == "t1w")' config.json > t1w.json
blJSON=t1w.json
bidsSub="sub-TTTEMPSUB"
ses="SSSES"

################################################################################
# setup bids dir structure

rm -rf $INDIRNAME && mkdir -p $INDIRNAME
rm -rf $WORKDIRNAME && mkdir -p $WORKDIRNAME
rm -rf $outdir && mkdir -p $outdir

# the bids dir will be inside ouf input
bidsDir=$INDIRNAME
bidsSubDir=$bidsDir/$bidsSub
bidsSubSesDir=$bidsSubDir/ses-$ses
mkdir -p $bidsSubSesDir

# if freesurfer provided, copy it to the same level as output dir
# TODO why can't we just symlink this in?
if [[ $inFSDIR != "null" ]] ; then

	mkdir -p $outdir/freesurfer

	# dont know if dir will be just inFSDIR or inFSDIR/output
	if [[ -d $inFSDIR/output ]] ; then
		cp -rv $inFSDIR/output $outdir/freesurfer/$bidsSub
	else
		cp -rv $inFSDIR $outdir/freesurfer/$bidsSub
	fi
fi

cat > $bidsDir/dataset_description.json << 'BIDSDESCRIPT'
{
    "Name": "temp",
    "BIDSVersion": "1.0.0"
}
BIDSDESCRIPT

################################################################################
# T1w 

mkdir -p $bidsSubSesDir/anat
blJSON_T1w=t1w.json
name_T1w=$bidsSubSesDir/anat/$bidsSub
name_T1w=$(bids_namekeyvals $name_T1w $blJSON_T1w "acq ce rec run" $ses )
cp $inT1w ${name_T1w}_T1w.nii.gz
jq -r ".meta" $blJSON_T1w > ${name_T1w}_T1w.json
bids_phaseencode_check ${name_T1w}_T1w.json

################################################################################
# T2w 

if [[ $inT2w != "null" ]] ; then
	jq '._inputs[] | select(.id == "t2w")' config.json > t2w.json
	blJSON_T2w=t2w.json
	name_T2w=$bidsSubSesDir/anat/$bidsSub
	name_T2w=$(bids_namekeyvals $name_T2w $blJSON_T2w "acq ce rec run" $ses )
	cp $inT2w ${name_T2w}_T2w.nii.gz
	jq -r ".meta" $blJSON_T2w > ${name_T2w}_T2w.json
	bids_phaseencode_check ${name_T2w}_T2w.json 
fi

################################################################################
# FMRI

if [[ $inFMRI != "null" ]] ; then

	mkdir -p $bidsSubSesDir/func
	jq '._inputs[] | select(.id == "fmri")' config.json > fmri.json
	blJSON_FMRI=fmri.json
	# fmri needs task in the filename to be defined!
	name_FMRI=$bidsSubSesDir/func/$bidsSub
	name_FMRI=$(bids_namekeyvals $name_FMRI $blJSON_FMRI "task acq ce dir rec run echo" $ses )
	cp $inFMRI ${name_FMRI}_bold.nii.gz
	jq -r ".meta" $blJSON_FMRI > ${name_FMRI}_bold.json
	bids_phaseencode_check ${name_FMRI}_bold.json 

fi

################################################################################
# FMAP

if [ $(jq .fieldmap config.json) != "null" ]; then
    jq '._inputs[] | select(.id == "fmap")' config.json > fmap.json

	mkdir -p $bidsSubSesDir/fmap

	# the fmri that the fmap is for
	relFMRI=$(echo ${name_FMRI}_bold.nii.gz | sed 's,.*/func/,/func/,')
    fieldmap_path=$(jq -r .fieldmap config.json) #might not exit but I am using ti find the path
    fmapDir=`dirname $fieldmap_path`

	# need to determine what type of fieldmap.
	# right now, support phasediff, epi

    ############ fmap / phasediff
    #phasediff.nii.gz/json
    #magnitude1.nii.gz/json
    #magnitude2.nii.gz/json
    if [ -f $(jq -r .phasediff config.json) ] ; then

		name_FMAP=$bidsSubSesDir/fmap/$bidsSub
		name_FMAP=$(bids_namekeyvals $name_FMAP fmap.json "acq run" $ses )

		# fmap actually has a few things associated with it, hence need to copy 
		# over additional stuff: fmap is actually:
		# phasediff.nii.gz, phasediff.json, 
		# and magnitude files

		rawPhaseDiff=$fmapDir/phasediff.nii.gz
		rawMagnitudes=($(ls -v $fmapDir/*magnitude*nii.gz))

		cp $rawPhaseDiff ${name_FMAP}_phasediff.nii.gz
		# replacing (or setting), the intended for category
		jq -r '.meta | .IntendedFor="'$relFMRI'"' fmap.json > ${name_FMAP}_phasediff.json

		for (( idx=0 ; idx<${#rawMagnitudes[@]} ; idx++ )) ; do
			cp ${rawMagnitudes[$idx]} ${name_FMAP}_magnitude$((idx+1)).nii.gz
            #TODO - what about _magnitue1/2.json?
		done

		bids_phaseencode_check ${name_FMAP}_phasediff.json 

        ############ fmap / 2phasemag
        #phase1.nii.gz / json
        #phase2.nii.gz / json
        #magnitude1.nii.gz /json
        #magnitude2.nii.gz / json
        #TODO..

        ############ fmap / real
        #fieldmap.nii.gz / json
        #magnitude.nii.gz
        #TODO.

        ############ fmap / epi
        #N.epi.nii.gz /json

    elif [ -f $(jq -r .ap config.json) ] ; then

		name_FMAP=$bidsSubSesDir/fmap/$bidsSub
		name_FMAP=$(bids_namekeyvals $name_FMAP fmap.json "acq ce dir run" $ses )

		# get just the direction value
		dirval=$(bids_namekeyvals "YO" fmap.json "dir" )
		dirval=$(echo $dirval | sed s,YO_dir-,,)

		# now make the name for 1 and 2
		name_FMAP_1=$(echo $name_FMAP | sed s,dir-$dirval,dir-1, )
		name_FMAP_2=$(echo $name_FMAP | sed s,dir-$dirval,dir-2, )

		imgs=($(ls $fmapDir/*epi*nii.gz ))
		# if there aren't exactly two images read
		if [[ ${#imgs[@]} -ne 2 ]] ; then
			echo "did not read to images for fmap. exiting"
			exit 1
		fi

		json1=$(echo ${imgs[0]} | sed s,nii.gz,json, )
		json2=$(echo ${imgs[1]} | sed s,nii.gz,json, )

		cp ${imgs[0]} ${name_FMAP_1}_epi.nii.gz
		cp ${imgs[1]} ${name_FMAP_2}_epi.nii.gz
		cp ${json1} ${name_FMAP_1}_epi.tmp.json
		cp ${json2} ${name_FMAP_2}_epi.tmp.json

		jq -r '.IntendedFor="'${relFMRI}'"' ${name_FMAP_1}_epi.tmp.json > ${name_FMAP_1}_epi.json
		jq -r '.IntendedFor="'${relFMRI}'"' ${name_FMAP_2}_epi.tmp.json > ${name_FMAP_2}_epi.json

		rm ${name_FMAP_1}_epi.tmp.json
		rm ${name_FMAP_2}_epi.tmp.json

		bids_phaseencode_check ${name_FMAP_1}_epi.json
		bids_phaseencode_check ${name_FMAP_2}_epi.json

	else
		echo "problem parsing fmap. exiting"
		exit 1
	fi

fi

###################################################################################################
#
# run fmriprep!
#

mkdir -p templateflow
export SINGULARITYENV_TEMPLATEFLOW_HOME=$PWD/templateflow

[ -z "$FREESURFER_LICENSE" ] && echo "Please set FREESURFER_LICENSE in .bashrc" && exit 1;
echo $FREESURFER_LICENSE > license.txt

time singularity exec -e docker://poldracklab/fmriprep:latest /usr/local/miniconda/bin/fmriprep \
    --notrack \
    --resource-monitor \
    --skip_bids_validation \
    --stop-on-first-crash \
    --use-plugin=multi_proc.yml \
    --output-spaces $outTEMPLATES \
    --force-bbr \
    --force-syn \
    --fs-license-file=license.txt \
    --skull-strip-template=NKI \
    --work-dir=$WORKDIRNAME \
    --participant_label=$bidsSub \
    $bidsDir $outdir participant

#--template-resampling-grid=2mm \

echo "done with fmriprep! - now organizing output"

# lets copy specifics out of the workdir
bloDir=$DERIVOUTNAME

#####################################################################################
#

# get basename
inFMRI=${name_FMRI}_bold.nii.gz
oDirFunc=$outdir/fmriprep/$bidsSub/ses-${ses}/func/
outBase="$oDirFunc/$(basename $(echo $inFMRI | sed s,_bold.nii.gz,, ))"

# get the preproc fmri vol
tmp=${outBase}_space-T1w_desc-preproc_bold.nii.gz
mkdir -p ${bloDir}_bold
cp -v $tmp ${bloDir}_bold/bold.nii.gz

# get the preproc fmri volmask
tmp=${outBase}_space-T1w_desc-brain_mask.nii.gz
mkdir ${bloDir}_boldmask
cp -v $tmp ${bloDir}_boldmask/mask.nii.gz

# get the confounds
tmp=${outBase}_desc-confounds_regressors.tsv
mkdir -p ${bloDir}_regress
cp -v $tmp ${bloDir}_regress/regressors.tsv

#####################################################################################
#
# ANAT STUFF

#inT1w=${name_T1w}_T1w.nii.gz
oDirAnat=$outdir/fmriprep/$bidsSub/anat/
outBase=$oDirAnat/$bidsSub

# get the preproc fmri vol
tmp=${outBase}_desc-preproc_T1w.nii.gz
mkdir -p ${bloDir}_t1/
cp -v $tmp ${bloDir}_t1/t1.nii.gz

tmp=${outBase}_desc-brain_mask.nii.gz
mkdir -p ${bloDir}_t1mask/
cp -v $tmp ${bloDir}_t1mask/mask.nii.gz

# save lots of space
rm -r $WORKDIRNAME

echo "all done"
