#!/bin/bash
#PBS -l nodes=1:ppn=8,walltime=9:00:00,vmem=14gb
#PBS -N fmriprep

set -x
set -e

bl2bids

#####################################################################################
#####################################################################################
#write out *plugin* configuration for fmriprep to limit mem/cpus
#this can't prevent the fmriprep/nipype bootup vmem spiking (could kill the job)
#but it seems to help...
cat <<EOF > multi_proc.yml
plugin: LegacyMultiProc
plugin_args: {maxtasksperchild: 1, memory_gb: 14, n_procs: 8, raise_insufficient: false}
EOF

#source bids_funcs.sh

WORKDIRNAME=fmripworkdir
outdir=fmripout
INDIRNAME=fmripinput

inT1w=`jq -r '.t1' config.json`
inT2w=`jq -r '.t2' config.json`
inFMRI=`jq -r '.fmri' config.json`
inFSDIR=`jq -r '.fsin' config.json`

space=$(jq -r .space config.json)

output_space=$space

#for volume output
resolution=$(jq -r .resolution config.json)
if [ $resolution != "original" ] && [ $resolution != "null" ] ;then
    output_space=$space:$resolution
fi

#####################################################################################
#####################################################################################
# some logical checks
if [[ $inT1w = "null" ]] || [[ $inFMRI = "null" ]] ; then
	echo "app needs minimally a T1w and fmri. exiting"
	exit 1
fi

# extract info from brainlife interface, base on T1w
# get the staging dir, this is where meta information is 
stagingDir=$(dirname $inT1w)
echo "ls dir where initial bl info read--> $stagingDir"
ls -dl $stagingDir

if [[ $stagingDir = "." ]]; then
   echo "error finding staging directory. exiting"
   exit 1
fi

jq '._inputs[] | select(.id == "t1w")' config.json > t1w.json
#TODO - strip alphanumeric chars
sub=$(jq -r .meta.subject t1w.json)
ses=$(jq -r .meta.session t1w.json)

#####################################################################################
#####################################################################################
# setup bids dir structure

# remove if stuff already exists
rm -rf $INDIRNAME && mkdir -p $INDIRNAME
rm -rf $WORKDIRNAME && mkdir -p $WORKDIRNAME
rm -rf $outdir && mkdir -p $outdir

# the bids dir will be inside our input
bidsDir=$INDIRNAME
bidsSubDir=$bidsDir/sub-$sub
bidsSubSesDir=$bidsSubDir/ses-$ses
mkdir -p $bidsSubSesDir

# if freesurfer provided, copy it to the same level as output dir
# TODO why can't we just symlink this in?
if [[ $inFSDIR != "null" ]] ; then
	mkdir -p $outdir/freesurfer
    cp -r $inFSDIR $outdir/freesurfer/sub-$sub
    chmod -R +rw $outdir/freesurfer
fi

# avoid templateflow problems on HPC's running singularity
mkdir -p templateflow
export SINGULARITYENV_TEMPLATEFLOW_HOME=$PWD/templateflow

# set FreeSurfer
[ -z "$FREESURFER_LICENSE" ] && echo "Please set FREESURFER_LICENSE in .bashrc" && exit 1;
echo $FREESURFER_LICENSE > license.txt

time singularity exec -e \
    docker://poldracklab/fmriprep:20.1.1 \
    /usr/local/miniconda/bin/fmriprep \
    --notrack \
    --resource-monitor \
    --skip-bids-validation \
    --md-only-boilerplate \
    --stop-on-first-crash \
    --use-plugin=multi_proc.yml \
    --output-spaces $output_space MNI152NLin2009cAsym \
    --force-bbr \
    --use-syn-sdc \
    --skull-strip-template=NKI \
    --work-dir=$WORKDIRNAME \
    --fs-license-file=license.txt \
    bids $outdir participant

#--participant_label=$sub \

echo "done with fmriprep! - now organizing output"

#####################################################################################
#####################################################################################
# reorganize outputs

####################
### bold outputs ###
####################

# get basename
inFMRI=${name_FMRI}_bold.nii.gz
oDirFunc=$outdir/fmriprep/sub-$sub/ses-$ses/func/
outBase="$oDirFunc/$(basename $(echo $inFMRI | sed s,_bold.nii.gz,, ))"

# first of all, get the confounds
tmp=${outBase}_desc-confounds_regressors.tsv
mkdir -p regress
mv -v $tmp regress/regressors.tsv

tmp=${outBase}_desc-confounds_regressors.json
if [[ -e $tmp ]] ; then
    mv -v $tmp regress/regressors.json
fi 

# need to check if we have surface or volume output,
# this will match for fsaverage, fsaverage5, ...
product=""
if [[ $space =~ 'fsaverage' ]] || [[ $space == 'fsnative' ]] ; then
    # fsaverage (for the future)
    mkdir -p surface
    tmp=${outBase}_space-${space}_hemi-L.func.gii
    mv -v $tmp surface/left_data.gii
    tmp=${outBase}_space-${space}_hemi-R.func.gii
    mv -v $tmp surface/right_data.gii

    if [[ $space =~ 'fsaverage' ]] ; then
        product="\"surface\": { \"meta\": { \"Space\": \"$space\" }, \"tags\": [ \"space-$space\"] },"
    fi
    if [[ $space == 'fsnative' ]] ; then
        #convert some freesurfer surfaces to gii
        product="\"surface\": { \"meta\": { \"Space\": \"native\" }, \"tag\": [ \"space-native\" ] },"

        time singularity exec -e -B `pwd`/license.txt:/usr/local/freesurfer/license.txt docker://brainlife/freesurfer_on_mcr:6.0.0 ./convertsurf.sh
    fi

else # else its a volume(bold) output
    product="\"bold_img\": {\"meta\": {\"Space\", \"$space\"}, \"tags\": [ \"space-$space\" ]},"

    # get the preproc fmri vol
    tmp=${outBase}_space-${space}_desc-preproc_bold.nii.gz
    mkdir -p bold_img
    mv -v $tmp bold_img/bold.nii.gz

    # get the preproc fmri volmask
    tmp=${outBase}_space-${space}_desc-brain_mask.nii.gz
    mkdir -p bold_mask
    mv -v $tmp bold_mask/mask.nii.gz

fi

###################
### T1w outputs ###
###################

#inT1w=${name_T1w}_T1w.nii.gz
oDirAnat=$outdir/fmriprep/sub-$sub/anat/
outBase=$oDirAnat/sub-$sub

# get the preproc t1w vol
tmp=${outBase}_desc-preproc_T1w.nii.gz
mkdir -p anat
mv -v $tmp anat/t1.nii.gz

tmp=${outBase}_desc-brain_mask.nii.gz
mkdir -p anat_mask
mv -v $tmp anat_mask/mask.nii.gz

##################
### reportlets ###
##################

mkdir -p output_report
html=$(cd $outdir && find ./ -name "*.html")
mkdir -p output_report/$(dirname $html)
cp $outdir/$html output_report/$html
for dir in $(cd $outdir && find ./ -name figures); do
    mkdir -p output_report/$(dirname $dir)
    cp -r $outdir/$dir output_report/$(dirname $dir)
done
mv output_report/fmriprep output_report/html #rename the parent directory to confirm to brainlife html output

cat << EOF > product.json
{
    $product
    "brainlife": [
        {
            "type": "html",
            "name": "fmriprep report (todo)",
            "desc": "we could show the content of the html report here",
            "path": "output_report"
        }
    ]
}
EOF

#####################################################################################
#####################################################################################

# save lots of space
rm -r $WORKDIRNAME

echo "all done"
